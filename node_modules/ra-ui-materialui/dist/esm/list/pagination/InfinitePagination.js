var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import { useEffect, useRef } from 'react';
import { useInfinitePaginationContext, useListContext, useEvent, } from 'ra-core';
import { Box, CircularProgress } from '@mui/material';
import { Offline } from '../../Offline';
/**
 * A pagination component that loads more results when the user scrolls to the bottom of the list.
 *
 * Used as the default pagination component in the <InfiniteList> component.
 *
 * @example
 * import { InfiniteList, InfinitePagination, Datagrid, TextField } from 'react-admin';
 *
 * const PostList = () => (
 *    <InfiniteList pagination={<InfinitePagination sx={{ py: 5 }} />}>
 *       <Datagrid>
 *          <TextField source="id" />
 *         <TextField source="title" />
 *      </Datagrid>
 *   </InfiniteList>
 * );
 */
export var InfinitePagination = function (_a) {
    var _b = _a.offline, offline = _b === void 0 ? defaultOffline : _b, _c = _a.options, options = _c === void 0 ? defaultOptions : _c, sx = _a.sx;
    var _d = useListContext(), isPaused = _d.isPaused, isPending = _d.isPending;
    var _e = useInfinitePaginationContext(), fetchNextPage = _e.fetchNextPage, hasNextPage = _e.hasNextPage, isFetchingNextPage = _e.isFetchingNextPage;
    if (!fetchNextPage) {
        throw new Error('InfinitePagination must be used inside an InfinitePaginationContext, usually created by <InfiniteList>. You cannot use it as child of a <List> component.');
    }
    var _f = React.useState(false), hasRequestedNextPage = _f[0], setHasRequestedNextPage = _f[1];
    var observerElem = useRef(null);
    var handleObserver = useEvent(function (entries) {
        var target = entries[0];
        if (target.isIntersecting && hasNextPage && !isFetchingNextPage) {
            setHasRequestedNextPage(true);
            fetchNextPage();
        }
    });
    useEffect(function () {
        // Whenever the query is unpaused, reset the requested next page state
        if (!isPaused) {
            setHasRequestedNextPage(false);
        }
    }, [isPaused]);
    useEffect(function () {
        var element = observerElem.current;
        if (!element)
            return;
        var observer = new IntersectionObserver(handleObserver, options);
        observer.observe(element);
        return function () { return observer.unobserve(element); };
    }, [
        fetchNextPage,
        hasNextPage,
        handleObserver,
        options,
        isPending,
        isFetchingNextPage,
    ]);
    if (isPending)
        return null;
    var showOffline = isPaused &&
        hasNextPage &&
        hasRequestedNextPage &&
        offline !== false &&
        offline !== undefined;
    return (React.createElement(Box, { ref: observerElem, sx: __spreadArray([
            {
                py: 2,
                textAlign: 'center',
            }
        ], (Array.isArray(sx) ? sx : [sx]), true) }, showOffline ? (offline) : isFetchingNextPage && hasNextPage ? (React.createElement(CircularProgress, { size: "1.5em" })) : null));
};
var defaultOptions = { threshold: 0 };
var defaultOffline = React.createElement(Offline, null);
//# sourceMappingURL=InfinitePagination.js.map