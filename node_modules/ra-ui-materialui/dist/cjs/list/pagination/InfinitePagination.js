"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InfinitePagination = void 0;
var React = __importStar(require("react"));
var react_1 = require("react");
var ra_core_1 = require("ra-core");
var material_1 = require("@mui/material");
var Offline_1 = require("../../Offline");
/**
 * A pagination component that loads more results when the user scrolls to the bottom of the list.
 *
 * Used as the default pagination component in the <InfiniteList> component.
 *
 * @example
 * import { InfiniteList, InfinitePagination, Datagrid, TextField } from 'react-admin';
 *
 * const PostList = () => (
 *    <InfiniteList pagination={<InfinitePagination sx={{ py: 5 }} />}>
 *       <Datagrid>
 *          <TextField source="id" />
 *         <TextField source="title" />
 *      </Datagrid>
 *   </InfiniteList>
 * );
 */
var InfinitePagination = function (_a) {
    var _b = _a.offline, offline = _b === void 0 ? defaultOffline : _b, _c = _a.options, options = _c === void 0 ? defaultOptions : _c, sx = _a.sx;
    var _d = (0, ra_core_1.useListContext)(), isPaused = _d.isPaused, isPending = _d.isPending;
    var _e = (0, ra_core_1.useInfinitePaginationContext)(), fetchNextPage = _e.fetchNextPage, hasNextPage = _e.hasNextPage, isFetchingNextPage = _e.isFetchingNextPage;
    if (!fetchNextPage) {
        throw new Error('InfinitePagination must be used inside an InfinitePaginationContext, usually created by <InfiniteList>. You cannot use it as child of a <List> component.');
    }
    var _f = React.useState(false), hasRequestedNextPage = _f[0], setHasRequestedNextPage = _f[1];
    var observerElem = (0, react_1.useRef)(null);
    var handleObserver = (0, ra_core_1.useEvent)(function (entries) {
        var target = entries[0];
        if (target.isIntersecting && hasNextPage && !isFetchingNextPage) {
            setHasRequestedNextPage(true);
            fetchNextPage();
        }
    });
    (0, react_1.useEffect)(function () {
        // Whenever the query is unpaused, reset the requested next page state
        if (!isPaused) {
            setHasRequestedNextPage(false);
        }
    }, [isPaused]);
    (0, react_1.useEffect)(function () {
        var element = observerElem.current;
        if (!element)
            return;
        var observer = new IntersectionObserver(handleObserver, options);
        observer.observe(element);
        return function () { return observer.unobserve(element); };
    }, [
        fetchNextPage,
        hasNextPage,
        handleObserver,
        options,
        isPending,
        isFetchingNextPage,
    ]);
    if (isPending)
        return null;
    var showOffline = isPaused &&
        hasNextPage &&
        hasRequestedNextPage &&
        offline !== false &&
        offline !== undefined;
    return (React.createElement(material_1.Box, { ref: observerElem, sx: __spreadArray([
            {
                py: 2,
                textAlign: 'center',
            }
        ], (Array.isArray(sx) ? sx : [sx]), true) }, showOffline ? (offline) : isFetchingNextPage && hasNextPage ? (React.createElement(material_1.CircularProgress, { size: "1.5em" })) : null));
};
exports.InfinitePagination = InfinitePagination;
var defaultOptions = { threshold: 0 };
var defaultOffline = React.createElement(Offline_1.Offline, null);
//# sourceMappingURL=InfinitePagination.js.map