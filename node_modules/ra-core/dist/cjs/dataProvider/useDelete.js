"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDelete = void 0;
var react_query_1 = require("@tanstack/react-query");
var useDataProvider_1 = require("./useDataProvider");
var useMutationWithMutationMode_1 = require("./useMutationWithMutationMode");
var util_1 = require("../util");
/**
 * Get a callback to call the dataProvider.delete() method, the result and the loading state.
 *
 * @param {string} resource
 * @param {Params} params The delete parameters { id, previousData }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }
 *
 * @typedef Params
 * @prop params.id The resource identifier, e.g. 123
 * @prop params.previousData The record before the update is applied
 *
 * @returns The current mutation state. Destructure as [deleteOne, { data, error, isPending }].
 *
 * The return value updates according to the request state:
 *
 * - initial: [deleteOne, { isPending: false, isIdle: true }]
 * - start:   [deleteOne, { isPending: true }]
 * - success: [deleteOne, { data: [data from response], isPending: false, isSuccess: true }]
 * - error:   [deleteOne, { error: [error from response], isPending: false, isError: true }]
 *
 * The deleteOne() function must be called with a resource and a parameter object: deleteOne(resource, { id, previousData, meta }, options)
 *
 * This hook uses react-query useMutation under the hood.
 * This means the state object contains mutate, isIdle, reset and other react-query methods.
 *
 * @see https://tanstack.com/query/v5/docs/react/reference/useMutation
 *
 * @example // set params when calling the deleteOne callback
 *
 * import { useDelete, useRecordContext } from 'react-admin';
 *
 * const DeleteButton = () => {
 *     const record = useRecordContext();
 *     const [deleteOne, { isPending, error }] = useDelete();
 *     const handleClick = () => {
 *         deleteOne('likes', { id: record.id, previousData: record })
 *     }
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isPending} onClick={handleClick}>Delete</div>;
 * };
 *
 * @example // set params when calling the hook
 *
 * import { useDelete, useRecordContext } from 'react-admin';
 *
 * const DeleteButton = () => {
 *     const record = useRecordContext();
 *     const [deleteOne, { isPending, error }] = useDelete('likes', { id: record.id, previousData: record });
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isPending} onClick={() => deleteOne()}>Delete</button>;
 * };
 *
 * @example // TypeScript
 * const [delete, { data }] = useDelete<Product>('products', { id, previousData: product });
 *                    \-- data is Product
 */
var useDelete = function (resource, params, options) {
    if (params === void 0) { params = {}; }
    if (options === void 0) { options = {}; }
    var dataProvider = (0, useDataProvider_1.useDataProvider)();
    var queryClient = (0, react_query_1.useQueryClient)();
    var _a = options.mutationMode, mutationMode = _a === void 0 ? 'pessimistic' : _a, mutationOptions = __rest(options, ["mutationMode"]);
    var _b = (0, useMutationWithMutationMode_1.useMutationWithMutationMode)(__assign({ resource: resource }, params), __assign(__assign({}, mutationOptions), { mutationKey: [resource, 'delete', params], mutationMode: mutationMode, mutationFn: function (_a) {
            var resource = _a.resource, params = __rest(_a, ["resource"]);
            if (resource == null) {
                throw new Error('useDelete mutation requires a resource');
            }
            if (params.id == null) {
                throw new Error('useDelete mutation requires a non-empty id');
            }
            return dataProvider.delete(resource, params);
        }, updateCache: function (_a, _b) {
            var resource = _a.resource, params = __rest(_a, ["resource"]);
            var mutationMode = _b.mutationMode;
            // hack: only way to tell react-query not to fetch this query for the next 5 seconds
            // because setQueryData doesn't accept a stale time option
            var now = Date.now();
            var updatedAt = mutationMode === 'undoable' ? now + 5 * 1000 : now;
            var updateColl = function (old) {
                if (!old)
                    return old;
                var index = old.findIndex(
                // eslint-disable-next-line eqeqeq
                function (record) { return record.id == params.id; });
                if (index === -1) {
                    return old;
                }
                return __spreadArray(__spreadArray([], old.slice(0, index), true), old.slice(index + 1), true);
            };
            queryClient.setQueriesData({ queryKey: [resource, 'getList'] }, function (res) {
                if (!res || !res.data)
                    return res;
                var newCollection = updateColl(res.data);
                var recordWasFound = newCollection.length < res.data.length;
                return recordWasFound
                    ? {
                        data: newCollection,
                        total: res.total ? res.total - 1 : undefined,
                        pageInfo: res.pageInfo,
                    }
                    : res;
            }, { updatedAt: updatedAt });
            queryClient.setQueriesData({ queryKey: [resource, 'getInfiniteList'] }, function (res) {
                if (!res || !res.pages)
                    return res;
                return __assign(__assign({}, res), { pages: res.pages.map(function (page) {
                        var newCollection = updateColl(page.data);
                        var recordWasFound = newCollection.length < page.data.length;
                        return recordWasFound
                            ? __assign(__assign({}, page), { data: newCollection, total: page.total
                                    ? page.total - 1
                                    : undefined, pageInfo: page.pageInfo }) : page;
                    }) });
            }, { updatedAt: updatedAt });
            queryClient.setQueriesData({ queryKey: [resource, 'getMany'] }, function (coll) {
                return coll && coll.length > 0 ? updateColl(coll) : coll;
            }, { updatedAt: updatedAt });
            queryClient.setQueriesData({ queryKey: [resource, 'getManyReference'] }, function (res) {
                if (!res || !res.data)
                    return res;
                var newCollection = updateColl(res.data);
                var recordWasFound = newCollection.length < res.data.length;
                return recordWasFound
                    ? __assign(__assign({}, res), { data: newCollection, total: res.total - 1 }) : res;
            }, { updatedAt: updatedAt });
            return params.previousData;
        }, getSnapshot: function (_a) {
            var resource = _a.resource;
            var queryKeys = [
                [resource, 'getList'],
                [resource, 'getInfiniteList'],
                [resource, 'getMany'],
                [resource, 'getManyReference'],
            ];
            /**
             * Snapshot the previous values via queryClient.getQueriesData()
             *
             * The snapshotData ref will contain an array of tuples [query key, associated data]
             *
             * @example
             * [
             *   [['posts', 'getList'], { data: [{ id: 1, title: 'Hello' }], total: 1 }],
             *   [['posts', 'getMany'], [{ id: 1, title: 'Hello' }]],
             * ]
             *
             * @see https://tanstack.com/query/v5/docs/react/reference/QueryClient#queryclientgetqueriesdata
             */
            var snapshot = queryKeys.reduce(function (prev, queryKey) {
                return prev.concat(queryClient.getQueriesData({ queryKey: queryKey }));
            }, []);
            return snapshot;
        }, onSettled: function (result, error, variables, context) {
            // For deletion, we always refetch after error or success:
            context.snapshot.forEach(function (_a) {
                var queryKey = _a[0];
                queryClient.invalidateQueries({ queryKey: queryKey });
            });
        } })), mutate = _b[0], mutationResult = _b[1];
    var deleteOne = (0, util_1.useEvent)(function (callTimeResource, callTimeParams, callTimeOptions) {
        if (callTimeResource === void 0) { callTimeResource = resource; }
        if (callTimeParams === void 0) { callTimeParams = {}; }
        if (callTimeOptions === void 0) { callTimeOptions = {}; }
        return mutate(__assign({ resource: callTimeResource }, callTimeParams), callTimeOptions);
    });
    return [deleteOne, mutationResult];
};
exports.useDelete = useDelete;
//# sourceMappingURL=useDelete.js.map